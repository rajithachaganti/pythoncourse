Flask micro services:
------------------------
monolithic vs micro services
advantages,disadvantages of micro services
service to service interaction in micro services


Monolithic vs micro services : 
------------------------------
task - mvc flow 
     - mulitple sub stages
	 - service1 --> service2 --> service3
	 





UI      ----> Orchestrator
===========================
RPA     ----> Orchestrator
============================
Service1----> Service2

			API Call:
			------------
			Request URL    : 
			Request Method :
			Payload        : 


End point expose 
Service expose
Webservice implementation at server side 

UI, RPA ---> Clients
Orchestrator --> Service



python App.py 
-------------
UI:
-----
* app.add_route('/gui_services/{param}', microservices)
* app.add_route('/gui_services/api/{param}', logicservices)

app.add_route('/gui_services/cuser', authData)
app.add_route('/gui_services/cauth', authData)
app.add_route('/gui_services/ctoken', authData)



RPA:
------
app.add_route('/orch/api/{param}',orchestration_services)   


Orchestrator:
----------------
Imporatant modulsd :  

Orchestrationservices
services
settings

API Call mappings:
===================
1
----
@exceptionHandler
@fpd_app.route("/api/ldapUserDetails", methods=['POST'])
def ldap_user_details():
	pass
	
2
----
fpd_fai.add_url_rule('/countries','country list', get_country_list,  methods=['GET'])


3
-----

orch_services = Orchestrationservices()
app.add_route('/orch/api/{param}',orch_services)


microservices = Microservices()
app.add_route('/gui_services/{param}', microservices) 

Implementation:
-------------------

controller + service                       DAO
---------------------                      --------------------------
GET:
-------
Auth.py                                 Commons.py
	class Microservices::


POST:
---------

Orchestrationservices : on_get()

				API Call:
				------------
				Requeast URL : /orch/api/{param}
				Request method: GET 
				
	
Orchestrationservices : on_post()
							if isRoute(route_path, "/orch/api/processalarms"):

				API Call:
				------------
				Requeast URL : /orch/api/{param}
				Request method: POST
				Payload : 

				
From RPA:

Request URL     : http//orchestrator.com/orch/api/processmmloutput
Request Method  : POST
Payload 		: {....}


M1 : Collection-parser :
-----------------------
API CALL:
---------
Requet URL    : controller/__init__.py ==> api.add_resource(CollectionDetails, '/api/v1/dna/..)
Request Method: controller/col_cont.py ==> CollectionDetails: post()
Payload       : 



# REST API CALL
response = requests.post(config_dsp_url,
						 data=json.dumps(cfg_payload),
						 headers=headers
						 )








REST Web service API CALL for RPA :
------------------------------------
Reuquset URL    : /orch/api/{param}   App.py 
Request Method  : GET/POST            Orchestrationservices.py  on_get on_post
Payload 		:  

App.py
---------
orchestration_services=Orchestrationservices()

GET APIs:
---------
1. /orch/api/metrics
   GET 
2. /orch/api/heartbeat
   GET
   
For Orchestrationservices, GET method:
----------------------------------------
Request URL : '/orch/api/{param}'
Requet method : GET
Payload : "/orch/api/metrics"   (OR)
	      "/orch/api/heartbeat"

		  
		  on_get() --->     /orch/api/metrics
		  
controller      				service       		                dao     			DB				
----------------------------------------------------------------------------------------------------------			
Orchestrationservices.py 		 prometheus_client.py   
	def on_get()                     def   generate_latest()
			 generate_latest()
		  
		  
							/orch/api/heartbeat
							
							from prometheus_client import generate_latest ??
					        json.dumps({"status": "Alive"})    ?? where it is taking json.loads()
							
							
	def on_post() 		-->     data i.e, json_data
		                    /orch/api/processalarms
							/orch/api/heartbeat
							/orch/api/processmml
							/orch/api/processmmloutput
							/orch/api/movetomanual
								processalarms   processmml  processmmloutput   
								
								self.mmlhandler.process_alarms vs  alarms   55th line  ????
								
						orch_worker_pool.submit(self.mmlhandler.process_alarms, alarms)		
								self._work_queue.put(w)



/orch/api/processalarms: POST: 
controller      							service       		                dao     			DB				
----------------------------------------------------------------------------------------------------------			
Orchestrationservices.py 					 jsonvalidator.py             mmlhandler() 
   def on_post():								validate_alarm()              insert_json()
    validate_alarm(json_data)


Client           Service
 
Orchestrator to Predictor :  r = requests.post(settings.PREDICT_URL, json=alarmjson)
							 r = requests.post(settings.PREDICT_URL, json=alarmjson, proxies=settings.NO_PROXY)
							 r = requests.post(settings.PREDICT_URL, json=alarmjson, proxies=settings.NO_PROXY)
							 
							 
Predictor to ParserSubstitutor:  post_to_resource(SUBSTITUTOR_RESOURCE_URL, alarm_session.output_json)
                                 r = requests.post(_resource_url, json=_dict)
								 
ParserSubstitutor to Predictor : PREDICTOR_RESOURCE_URL = 'http://localhost:8000/predictor_api/get_next_command/'
								predictor_response = post_to_resource(PREDICTOR_RESOURCE_URL, _dict)
									r = requests.post(_resource_url, json=_dict, proxies=ignoreproxies)
									
									
									
									
micro services call:
---------------------
Orchestrationservices
	on_post:
		/orch/api/processmmloutput
			orch_worker_pool.submit(self.mmlhandler.process_mmloutput_from_rpa, json_data)
				process_mmloutput_from_rpa
					self.send_mmloutput_to_ps(rpaoutput['robotUID'])
						send_mmloutput_to_ps
							r = requests.post(settings.PREDICT_URL, json=alarmjson, proxies=settings.NO_PROXY)

www.websequencediagrams.com
